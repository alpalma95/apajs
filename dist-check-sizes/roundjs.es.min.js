let{isArray:t}=Array;class e extends HTMLElement{constructor(){super()}connectedCallback(){this.getProps();let e=this.shadowRoot?this.shadowRoot:this,s=(n=this.ctx.render(this.ctx)??this.render(),t(n)?n.map((t=>"string"==typeof t?document.createTextNode(t):t)):"string"==typeof n?document.createTextNode(n):n);var n;t(s)?s.forEach((t=>e.appendChild(t))):e.appendChild(s),this.onInit()}attributeChangedCallback(t,e,s){t.startsWith(":")?this[t.slice(1)]=s:this[t]=s,this.watch(t.slice(1),JSON.parse(e),JSON.parse(s))}disconnectedCallback(){this.onDestroy()}getProps(){this.getAttributeNames().forEach((t=>{if(!t.startsWith(":"))return;let e={};e[t.slice(1)]=JSON.parse(this.getAttribute(t)),this.ctx?this.ctx.props=e:this.props=e}))}watch(t,e,s){}onInit(){}onDestroy(){}render(){}}let s=(t,s,n={})=>{window.customElements.define(t,class extends e{constructor(){super(),this.ctx=(t=>{for(let e of Object.keys(t))"function"==typeof t[e]&&(t[e]=t[e].bind(t));return t})(s),this.ctx.getHost=()=>this,n.shadow&&this.attachShadow({mode:n.shadow})}onInit(){this.ctx.onInit&&this.ctx.onInit(this)}onDestroy(){this.ctx.onDestroy&&this.ctx.onDestroy(this)}watch(t,e,s){this.ctx.watch&&this.ctx.watch(t,e,s,this)}})};let n,i,o,r,l,a=Object,d=a.getPrototypeOf,c=document,h={isConnected:1},f={},u=d(h),p=d(d),_=(t,e,s,n)=>(t??(setTimeout(s,n),new Set)).add(e),g=(t,e,s)=>{let n=o;o=e;try{return t(s)}catch(t){return s}finally{o=n}},v=t=>t.filter((t=>{var e;return null==(e=t._dom)?void 0:e.isConnected})),m=t=>l=_(l,t,(()=>{for(let t of l)t._bindings=v(t._bindings),t._listeners=v(t._listeners);l=n}),1e3),b={get val(){return null==o||o.add(this),this._val},get oldVal(){return null==o||o.add(this),this._oldVal},set val(t){let e=this;if(t!==e._val){e._val=t;let s=[...e._listeners=v(e._listeners)];for(let t of s)C(t.f,t.s,t._dom),t._dom=n;e._bindings.length?i=_(i,e,V):e._oldVal=t}}},y=t=>({__proto__:b,_val:t,_oldVal:t,_bindings:[],_listeners:[]}),w=t=>d(t??0)===b,x=(t,e)=>{let s=new Set,n={f:t},i=r;r=[];let o=g(t,s,e);o=(o??c).nodeType?o:new Text(o);for(let t of s)m(t),t._bindings.push(n);for(let t of r)t._dom=o;return r=i,n._dom=o},C=(t,e=y(),s)=>{let n=new Set,i={f:t,s:e};i._dom=s??(null==r?void 0:r.push(i))??h,e.val=g(t,n);for(let t of n)m(t),t._listeners.push(i);return e},S=(t,...e)=>{for(let s of e.flat(1/0)){let e=d(s??0),i=e===b?x((()=>s.val)):e===p?x(s):s;i!=n&&t.append(i)}return t},O=t=>new Proxy(((e,...s)=>{var i;let[o,...r]=d(s[0]??0)===u?s:[{},...s],l=t?c.createElementNS(t,e):c.createElement(e);for(let[t,s]of a.entries(o)){let o=e=>e?a.getOwnPropertyDescriptor(e,t)??o(d(e)):n,r=e+","+t,c=f[r]??(f[r]=(null==(i=o(d(l)))?void 0:i.set)??0),h=c?c.bind(l):l.setAttribute.bind(l,t),u=d(s??0);u===b?x((()=>(h(s.val),l))):u!==p||t.startsWith("on")&&!s._isBindingFunc?h(s):x((()=>(h(s()),l)))}return S(l,...r)}),{get:(t,e)=>t.bind(n,e)}),N=(t,e)=>e?e!==t&&t.replaceWith(e):t.remove(),V=()=>{let t=[...i].filter((t=>t._val!==t._oldVal));i=n;for(let e of new Set(t.flatMap((t=>t._bindings=v(t._bindings)))))N(e._dom,x(e.f,e._dom)),e._dom=n;for(let e of t)e._oldVal=e._val};const E={add:S,_:t=>(t._isBindingFunc=1,t),tags:O(),tagsNS:O,state:y,val:t=>w(t)?t.val:t,oldVal:t=>w(t)?t.oldVal:t,derive:C,hydrate:(t,e)=>N(t,x(e,t))};const D=function(t){for(var e,s,n=arguments,i=1,o="",r="",l=[0],a=function(t){1===i&&(t||(o=o.replace(/^\s*\n\s*|\s*\n\s*$/g,"")))?l.push(t?n[t]:o):3===i&&(t||o)?(l[1]=t?n[t]:o,i=2):2===i&&"..."===o&&t?l[2]=Object.assign(l[2]||{},n[t]):2===i&&o&&!t?(l[2]=l[2]||{})[o]=!0:i>=5&&(5===i?((l[2]=l[2]||{})[s]=t?o?o+n[t]:n[t]:o,i=6):(t||o)&&(l[2][s]+=t?o+n[t]:o)),o=""},d=0;d<t.length;d++){d&&(1===i&&a(),a(d));for(var c=0;c<t[d].length;c++)e=t[d][c],1===i?"<"===e?(a(),l=[l,"",null],i=3):o+=e:4===i?"--"===o&&">"===e?(i=1,o=""):o=e+o[0]:r?e===r?r="":o+=e:'"'===e||"'"===e?r=e:">"===e?(a(),i=1):i&&("="===e?(i=5,s=o,o=""):"/"===e&&(i<5||">"===t[d][c+1])?(a(),3===i&&(l=l[0]),i=l,(l=l[0]).push(this.apply(null,i.slice(1))),i=0):" "===e||"\t"===e||"\n"===e||"\r"===e?(a(),i=2):o+=e),3===i&&"!--"===o&&(i=4,l=l[0])}return a(),l.length>2?l.slice(1):l[1]}.bind((function(t,e,...s){const n=E.tags[t];return e?n(e,...s):n(...s)}));let{fromEntries:T,entries:j}=Object,A=t=>"object"!=typeof t?I(t):T(j(t).map((([t,e])=>[t,A(e)])));const{state:I,derive:P}=E;export{e as ReactiveWC,s as defineComponent,P as derive,D as html,A as reactive,I as state};
//# sourceMappingURL=roundjs.min.js.map